import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import axios from '../../app/axios';

const initialState = {
  value: 0,
  allVotes:[],
  status: 'idle',
  isFetching: false,
  isSuccess: false,
  isError: false,
  errorMessage: '',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchVoteAsync = createAsyncThunk(
  'vote/fetchVote',
  async (udata, thunkAPI) => {
    try {
      const response = await axios.get('/votes');

      let data = response.data;
      if (response.status === 200) {
        return data;
      } else {
        return thunkAPI.rejectWithValue(data);
      }
    } catch (err) {
      // thunkAPI.rejectWithValue(e.response.data);
      if (!err.response) {
        throw err
      }

      return thunkAPI.rejectWithValue(err.response.data)
    }
  }
);

export const createVoteAsync = createAsyncThunk(
  'vote/createVote',
  async (udata, thunkAPI) => {
    try {
      const response = await axios.post('/votes/create',udata);

      let data = response.data;
      console.log('vote data',data)
      if (response.status === 201  || response.status === 200) {
        return data;
      } else {
        return thunkAPI.rejectWithValue(data);
      }
    } catch (err) {
      // thunkAPI.rejectWithValue(e.response.data);
      if (!err.response) {
        throw err
      }

      return thunkAPI.rejectWithValue(err.response.data)
    }
  }
);

export const voteSlice = createSlice({
  name: 'vote',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: {
    [fetchVoteAsync.fulfilled]: (state, { payload }) => {
      state.value = payload?.votes;
      state.allVotes = payload?.data;
      state.isFetching = false;
      state.isSuccess = true;
      return state;
    },
    [fetchVoteAsync.pending]: (state) => {
      state.isFetching = true;
    },
    [fetchVoteAsync.rejected]: (state, { payload }) => {
      state.isFetching = false;
      state.isError = true;
      if(payload){
        state.errorMessage = payload.message;
      }
      else{
        state.errorMessage = 'Internal error';
      }
    },
    [createVoteAsync.fulfilled]: (state, { payload }) => {
     // state.value = payload?.votes;
      //state.allVotes = payload?.data;
      state.isFetching = false;
      state.isSuccess = true;
      return state;
    },
    [createVoteAsync.pending]: (state) => {
      state.isFetching = true;
    },
    [createVoteAsync.rejected]: (state, { payload }) => {
      state.isFetching = false;
      state.isError = true;
      if(payload){
        state.errorMessage = payload.message;
      }
      else{
        state.errorMessage = 'Internal error';
      }
    }
  },
});

export const {  } = voteSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectCount = (state) => state.vote.value;

export default voteSlice.reducer;
